%row
  .col-xs-12
    #visualization
      .item-x3
        %canvas.visualizer
      .item
        %input#refresh{type:"TEXT", value: "10", }
    %audio#jp_audio_i{src:"http://localhost:9292/stream/10"}
 
:javascript
  var visualization_enabled = true;
  $(document).ready(function() {
    $("#jquery_jplayer_1").bind($.jPlayer.event.loadstart, function (event) {
      visualization_enabled = false;
      console.log("setMedia");
      var audio = event.currentTarget.childNodes[1];
      visualize(audio);
    });
  });

  function visualize(audio) {
    visualization_enabled = true;
    var ctx = new AudioContext();
    //var audio = $("audio#jp_audio_i")[0];
    var audioSrc = ctx.createMediaElementSource(audio);
    var analyser = ctx.createAnalyser();

    var canvas = document.querySelector('.visualizer');
    var canvasCtx = canvas.getContext("2d");
    var drawVisual;

    var WIDTH = canvas.width;
    var HEIGHT = canvas.height;

    analyser.fftSize = 2048;

    // we have to connect the MediaElementSource with the analyser 
    audioSrc.connect(analyser);
    audioSrc.connect(ctx.destination);
    // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)
   
    // frequencyBinCount tells you how many values you'll receive from the analyser
    var bufferLength = analyser.frequencyBinCount;
    var dataArray = new Uint8Array(bufferLength);
    var nextColor = null;
    
    canvasCtx.fillStyle = 'rgb(20,20,20)';
    canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

    function randomNumber(limit) {
      return Math.ceil(Math.random() * limit);
    }

    function randomNumbers(count, limit) {
      var ret = new Array();
      for(var i = 0; i<count; i++) {
        ret.push(randomNumber(limit));
      }

    function formatColor(nums) {
      return 'rgb(' + nums[0] + ',' + nums[1] + ',' + nums[2] + ')';
    }

    function parseColor(color) {
      var regex = 'rgb\(([0-9]*),([0-9]*),([0-9]*)\)'
      var matches = regex.exec(color);
      var ret = new Array();
      for(var i = 0; i<matches.length; i++) {
        ret.push(matches[i]);
      }
      return ret;
    }

    function mutateColor(currentColor, target) {
      var current = parseColor(currentColor);
      for(var i = 0; i<current.length; i++) {
        if(current[i] == target[i]) {
          continue;
        }else if(current[i] < target[i]) { 
          current[i] += 1; 
        }else
          current[i] -= 1;
        }
      }
      return current;
    }

    //renderFrame();
    function draw(iter) {
      //drawVisual = requestAnimationFrame(draw);
      var refresh = document.getElementById("refresh").value;
      analyser.getByteTimeDomainData(dataArray);
      //canvasCtx.fillStyle = 'rgb(0, 0, 20)';

      //mutate background color
      var next = formatColor(mutateColor(canvas.fillStyle));

      if(nextColor == canvasCtx.fillStyle) {
        nextColor = formatColor(randomNumbers(3, 255));
      }else {
        canvasCtx.fillStyle = next;
      }
        
      canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
      canvasCtx.lineWidth = 1.8;
      if(iter%1==0) {
        canvasCtx.strokeStyle = randomColor(iter);
      }

      canvasCtx.beginPath();

      var sliceWidth = WIDTH * 1.0 / bufferLength;
      var x = 0;
      for(var i = 0; i < bufferLength; i++) {
   
        var v = dataArray[i] / 128.0;
        var y = v * HEIGHT/2;

        if(i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }
      canvasCtx.lineTo(canvas.width, canvas.height/2);
      canvasCtx.stroke();
      //draw();
      if(visualization_enabled) {
        window.setTimeout( function() { requestAnimationFrame( function() { draw(++iter); })}, refresh );
      }
    }
    
      window.setTimeout( function() { requestAnimationFrame( function() { draw(0); })}, refresh);
  }
